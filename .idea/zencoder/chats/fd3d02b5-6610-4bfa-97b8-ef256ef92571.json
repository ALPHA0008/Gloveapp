{
    "checksum": "869b5b8e8ee877f467933812b2f0c79ec453c21e2ad5329a959b6d6d0872d46d",
    "data": {
    "id": "fd3d02b5-6610-4bfa-97b8-ef256ef92571",
    "createdAt": 1750331560131,
    "updatedAt": 1750331714188,
    "title": "Kotlin Error Resolution and Optimization",
    "messages": [
        {
            "id": "3613a20e-d1f3-49bc-915b-0518f2244627",
            "role": "user",
            "content": [
                {
                    "type": "command",
                    "commandName": "fix"
                },
                {
                    "type": "codeSnippet",
                    "text": "PatientProfileScreen(\n                            patientUsername = \"Placeholder\", // Update with selected patient\n                            onBack = {\n                                currentScreen = AppScreen.PATIENT_LIST",
                    "language": "kotlin"
                },
                {
                    "type": "text",
                    "text": "Unresolved reference 'PatientProfileScreen'."
                }
            ],
            "context": {
                "currentFile": {
                    "path": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\MainActivity.kt",
                    "fsPath": "C:/Users/abhi/AndroidStudioProjects/Gloveapp/app/src/main/java/com/example/gloveapp/MainActivity.kt",
                    "content": "package com.example.gloveapp\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.bluetooth.*\nimport android.bluetooth.le.*\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.location.LocationManager\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.Handler\nimport android.os.Looper\nimport android.provider.Settings\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.annotation.RequiresPermission\nimport androidx.compose.animation.Crossfade\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.runtime.*\nimport androidx.compose.runtime.snapshots.SnapshotStateList\nimport androidx.core.content.ContextCompat\nimport androidx.datastore.preferences.preferencesDataStore\nimport androidx.datastore.preferences.core.booleanPreferencesKey\nimport androidx.datastore.preferences.core.edit\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.text.input.KeyboardType\nimport androidx.compose.ui.text.input.PasswordVisualTransformation\nimport androidx.compose.ui.unit.dp\nimport com.github.mikephil.charting.data.Entry\nimport com.example.gloveapp.ui.theme.GloveAppTheme\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.flow.Flow\nimport java.util.*\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.cancel\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.delay\nimport java.util.Collections\nimport retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\nimport kotlinx.coroutines.launch\n\nval Context.dataStore by preferencesDataStore(name = \"settings\")\n\nenum class UserRole {\n    ADMIN, DOCTOR, PATIENT\n}\n\ndata class User(\n    val username: String,\n    val password: String, // In production, use hashed passwords\n    val role: UserRole,\n    val doctorUsername: String? = null // For patients, links to their doctor\n)\n\ndata class PatientDoctorLink(\n    val patientUsername: String,\n    val doctorUsername: String,\n    val isApproved: Boolean\n)\n\nclass MainActivity : ComponentActivity() {\n\n    companion object {\n        private const val TAG = \"BLE_DEBUG_TIMER\"\n        private val SERVICE_UUID = UUID.fromString(\"6e400001-b5a3-f393-e0a9-e50e24dcca9e\")\n        private val CHARACTERISTIC_NOTIFY_UUID = UUID.fromString(\"6e400003-b5a3-f393-e0a9-e50e24dcca9e\")\n        private val CHARACTERISTIC_WRITE_UUID = UUID.fromString(\"6e400002-b5a3-f393-e0a9-e50e24dcca9e\")\n        private val CLIENT_CHAR_CONFIG_UUID = UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\")\n        val IS_DARK_MODE_KEY = booleanPreferencesKey(\"is_dark_mode\")\n        private const val MAX_DATA_POINTS = 5000\n        private const val CHART_UPDATE_INTERVAL = 100L\n        private const val DATA_STREAM_DURATION_MS = 120_000L\n    }\n\n    private lateinit var bluetoothAdapter: BluetoothAdapter\n    private var bluetoothLeScanner: BluetoothLeScanner? = null\n    private val mainHandler = Handler(Looper.getMainLooper())\n    private var connectedGatt: BluetoothGatt? = null\n    private var controlCharacteristic: BluetoothGattCharacteristic? = null\n    private var pNotifyCharacteristic: BluetoothGattCharacteristic? = null\n    private val buffer = StringBuilder()\n    private val coroutineScope = CoroutineScope(Dispatchers.Default + Job())\n\n    private val _fsrEntriesInternal = List(5) { mutableListOf<Entry>() }\n    private val _flexEntriesInternal = List(5) { mutableListOf<Entry>() }\n    private val _imuBioEntriesInternal = List(7) { mutableListOf<Entry>() }\n    val fsrEntries: SnapshotStateList<List<Entry>> = mutableStateListOf(\n        emptyList(), emptyList(), emptyList(), emptyList(), emptyList()\n    )\n    val flexEntries: SnapshotStateList<List<Entry>> = mutableStateListOf(\n        emptyList(), emptyList(), emptyList(), emptyList(), emptyList()\n    )\n    val imuBioEntries: SnapshotStateList<List<Entry>> = mutableStateListOf(\n        emptyList(), emptyList(), emptyList(), emptyList(), emptyList(), emptyList(), emptyList()\n    )\n\n    private var dataUpdateTrigger by mutableStateOf(0)\n    private var xIndex = 0f\n\n    private var isDarkThemeEnabled by mutableStateOf(false)\n    private val dataBuffer = Collections.synchronizedList(mutableListOf<List<Float>>())\n    private var chartUpdateJob: Job? = null\n\n    private val windowSize = 5\n    private val fsrMovingAverages = List(5) { mutableListOf<Float>() }\n    private val flexMovingAverages = List(5) { mutableListOf<Float>() }\n    private val imuBioMovingAverages = List(7) { mutableListOf<Float>() }\n\n    private var scanning by mutableStateOf(false)\n    private val scannedDevices = mutableStateListOf<ScannedDeviceInfo>()\n    private val rssiMap = mutableStateMapOf<String, Int>()\n\n    private var onScanAttemptResult: ((Boolean) -> Unit)? = null\n\n    private var isDataStreamingEnabled by mutableStateOf(false)\n    private var isDeviceReadyForControl by mutableStateOf(false)\n\n    private var isTimerRunning by mutableStateOf(false)\n    private var timerStartTimeMillis by mutableStateOf(0L)\n    private var timerAccumulatedMillis by mutableStateOf(0L)\n\n    // In-memory user store (replace with a backend like Firebase in production)\n    private val users = mutableStateListOf<User>()\n    private val patientDoctorLinks = mutableStateListOf<PatientDoctorLink>()\n    private var currentUser by mutableStateOf<User?>(null)\n\n    private val requestPermissionsLauncher =\n        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->\n            val allPermissionsGranted = permissions.entries.all { it.value }\n            if (allPermissionsGranted) {\n                checkBluetoothAndLocationStatus { success ->\n                    onScanAttemptResult?.invoke(success)\n                }\n            } else {\n                Toast.makeText(this, \"Required permissions denied.\", Toast.LENGTH_LONG).show()\n                onScanAttemptResult?.invoke(false)\n            }\n        }\n\n    private val enableBluetoothLauncher =\n        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->\n            Log.d(TAG, \"Bluetooth enable result: ${result.resultCode == RESULT_OK}\")\n            if (result.resultCode == RESULT_OK) {\n                checkLocationServiceStatus { success ->\n                    onScanAttemptResult?.invoke(success)\n                }\n            } else {\n                Toast.makeText(this, \"Bluetooth not enabled.\", Toast.LENGTH_LONG).show()\n                onScanAttemptResult?.invoke(false)\n            }\n        }\n\n    private val enableLocationLauncher =\n        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n            Log.d(TAG, \"Location enable result.\")\n            checkBluetoothAndLocationStatus { success ->\n                onScanAttemptResult?.invoke(success)\n            }\n        }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        Log.d(TAG, \"MainActivity onCreate.\")\n        initializeBluetooth()\n        initializeRetrofit()\n        setupChartUpdateJob()\n\n        // Initialize with an admin user (for testing; secure this in production)\n        users.add(User(\"admin\", \"admin123\", UserRole.ADMIN))\n\n        val isDarkFlow: Flow<Boolean> = dataStore.data\n            .map { preferences ->\n                preferences[IS_DARK_MODE_KEY] ?: false\n            }\n\n        handleComposeUI(isDarkFlow)\n    }\n\n    private lateinit var patientApi: PatientApi\n\n    private fun initializeRetrofit() {\n        val retrofit = Retrofit.Builder()\n            .baseUrl(\"http://172.24.131.197:8080/\") // Use your server IP in production\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n        patientApi = retrofit.create(PatientApi::class.java)\n    }\n\n    private fun fetchPatients() {\n        coroutineScope.launch {\n            try {\n                val patients = patientApi.getPatients()\n                Log.d(TAG, \"Fetched patients: $patients\")\n                // Update UI or store patients if needed\n            } catch (e: Exception) {\n                Log.e(TAG, \"Error fetching patients: ${e.message}\")\n            }\n        }\n    }\n\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(TAG, \"MainActivity onDestroy.\")\n        disconnectGatt()\n        chartUpdateJob?.cancel()\n        coroutineScope.cancel()\n    }\n\n    private fun initializeBluetooth() {\n        val bluetoothManager = getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager\n        bluetoothAdapter = bluetoothManager.adapter\n        Log.d(TAG, \"BluetoothAdapter initialized. Is null: ${bluetoothAdapter == null}\")\n\n        if (bluetoothAdapter == null) {\n            Toast.makeText(this, \"Bluetooth not supported.\", Toast.LENGTH_LONG).show()\n            finish()\n        }\n    }\n\n    private fun setupChartUpdateJob() {\n        chartUpdateJob?.cancel()\n        chartUpdateJob = coroutineScope.launch {\n            Log.d(TAG, \"Chart update job started.\")\n            while (true) {\n                delay(CHART_UPDATE_INTERVAL)\n                if (dataBuffer.isNotEmpty()) {\n                    processBufferedData()\n                }\n            }\n        }\n    }\n\n    @OptIn(ExperimentalMaterial3Api::class)\n    @SuppressLint(\"MissingPermission\")\n    private fun handleComposeUI(isDarkFlow: Flow<Boolean>) {\n        setContent {\n            val darkThemeFromPrefs by isDarkFlow.collectAsState(initial = isSystemInDarkTheme())\n            isDarkThemeEnabled = darkThemeFromPrefs\n\n            GloveAppTheme(darkTheme = isDarkThemeEnabled) {\n                var currentScreen by remember { mutableStateOf(AppScreen.SIGN_IN) }\n                var scanInitiatedState by remember { mutableStateOf(false) }\n                var isLoadingPermissions by remember { mutableStateOf(false) }\n\n                onScanAttemptResult = { success ->\n                    isLoadingPermissions = false\n                    Log.d(TAG, \"onScanAttemptResult: success=$success\")\n                    if (!success) {\n                        scanInitiatedState = false\n                    }\n                }\n\n                Crossfade(\n                    targetState = currentScreen,\n                    animationSpec = tween(durationMillis = 500)\n                ) { targetScreen ->\n                    when (targetScreen) {\n                        AppScreen.SIGN_IN -> SignInScreen(\n                            onSignIn = { username, password ->\n                                val user = users.find { it.username == username && it.password == password }\n                                if (user != null) {\n                                    if (user.role == UserRole.PATIENT) {\n                                        val link = patientDoctorLinks.find { it.patientUsername == username }\n                                        if (link?.isApproved != true) {\n                                            Toast.makeText(this@MainActivity, \"Account pending doctor approval.\", Toast.LENGTH_LONG).show()\n                                            return@SignInScreen\n                                        }\n                                    }\n                                    currentUser = user\n                                    currentScreen = when (user.role) {\n                                        UserRole.ADMIN -> AppScreen.USER_MANUAL // Updated to USER_MANUAL\n                                        UserRole.DOCTOR -> AppScreen.PATIENT_LIST\n                                        UserRole.PATIENT -> AppScreen.SCAN\n                                    }\n                                    Toast.makeText(this@MainActivity, \"Signed in as ${user.role}\", Toast.LENGTH_SHORT).show()\n                                } else {\n                                    Toast.makeText(this@MainActivity, \"Invalid credentials.\", Toast.LENGTH_SHORT).show()\n                                }\n                            },\n                            onSignUpClick = {\n                                currentScreen = AppScreen.SIGN_UP\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            }\n                        )\n                        AppScreen.SIGN_UP -> SignUpScreen(\n                            onSignUp = { username, password, role, doctorUsername ->\n                                if (users.any { it.username == username }) {\n                                    Toast.makeText(this@MainActivity, \"Username already exists.\", Toast.LENGTH_SHORT).show()\n                                    return@SignUpScreen\n                                }\n                                if (role == UserRole.PATIENT && doctorUsername != null) {\n                                    if (!users.any { it.username == doctorUsername && it.role == UserRole.DOCTOR }) {\n                                        Toast.makeText(this@MainActivity, \"Doctor not found.\", Toast.LENGTH_SHORT).show()\n                                        return@SignUpScreen\n                                    }\n                                    patientDoctorLinks.add(PatientDoctorLink(username, doctorUsername, isApproved = false))\n                                }\n                                users.add(User(username, password, role, doctorUsername))\n                                Toast.makeText(this@MainActivity, \"Sign-up successful. ${if (role == UserRole.PATIENT) \"Pending doctor approval.\" else \"\"}\", Toast.LENGTH_LONG).show()\n                                currentScreen = AppScreen.SIGN_IN\n                            },\n                            onBackToSignIn = {\n                                currentScreen = AppScreen.SIGN_IN\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            }\n                        )\n                        AppScreen.USER_MANUAL -> UserManualScreen(\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            },\n                            onNextClick = {\n                                currentScreen = AppScreen.SCAN\n                            }\n                        )\n                        AppScreen.SCAN -> ScanScreen(\n                            devices = scannedDevices,\n                            rssiValues = rssiMap,\n                            isScanning = scanning,\n                            onScanClick = {\n                                scanInitiatedState = true\n                                isLoadingPermissions = true\n                                Log.d(TAG, \"Scan button clicked.\")\n                                requestBluetoothPermissions { success -> }\n                            },\n                            onDeviceClick = { device ->\n                                Log.d(TAG, \"Device clicked: ${device.address}\")\n                                connectToDevice(device)\n                                stopScan()\n                                currentScreen = AppScreen.GET_READY\n                            },\n                            scanInitiated = scanInitiatedState,\n                            isLoadingPermissions = isLoadingPermissions,\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            }\n                        )\n                        AppScreen.GET_READY -> GetReadyScreen(\n                            onCountdownComplete = {\n                                Log.d(TAG, \"GetReadyScreen: onCountdownComplete triggered.\")\n                                try {\n                                    writeDataControl(true)\n                                    currentScreen = if (currentUser?.role == UserRole.PATIENT) AppScreen.PATIENT_MAIN else AppScreen.MAIN\n                                    Log.d(TAG, \"GetReadyScreen: Transitioned to ${if (currentUser?.role == UserRole.PATIENT) \"PATIENT_MAIN\" else \"MAIN\"} screen.\")\n                                } catch (e: Exception) {\n                                    Log.e(TAG, \"Error in onCountdownComplete: ${e.message}\")\n                                    mainHandler.post {\n                                        Toast.makeText(this@MainActivity, \"Error starting data stream: ${e.message}\", Toast.LENGTH_LONG).show()\n                                        currentScreen = if (currentUser?.role == UserRole.PATIENT) AppScreen.PATIENT_MAIN else AppScreen.MAIN\n                                    }\n                                }\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            }\n                        )\n                        AppScreen.MAIN -> MainScreen(\n                            onScanClick = {\n                                Log.d(TAG, \"Disconnect and return to scan clicked.\")\n                                try {\n                                    writeDataControl(false)\n                                    disconnectGatt()\n                                    clearData()\n                                    scannedDevices.clear()\n                                    rssiMap.clear()\n                                    currentScreen = AppScreen.SCAN\n                                    scanInitiatedState = false\n                                } catch (e: Exception) {\n                                    Log.e(TAG, \"Error during disconnect: ${e.message}\")\n                                    Toast.makeText(this@MainActivity, \"Error disconnecting: ${e.message}\", Toast.LENGTH_SHORT).show()\n                                }\n                            },\n                            fsrEntries = fsrEntries,\n                            flexEntries = flexEntries,\n                            imuBioEntries = imuBioEntries,\n                            dataUpdateTrigger = dataUpdateTrigger,\n                            isDataStreamingEnabled = isDataStreamingEnabled,\n                            isDeviceReadyForControl = isDeviceReadyForControl,\n                            onStartStreaming = {\n                                Log.d(TAG, \"MainScreen: START STREAMING clicked.\")\n                                currentScreen = AppScreen.GET_READY\n                            },\n                            onStopStreaming = {\n                                Log.d(TAG, \"MainScreen: STOP STREAMING clicked.\")\n                                try {\n                                    writeDataControl(false)\n                                } catch (e: Exception) {\n                                    Log.e(TAG, \"Error stopping streaming: ${e.message}\")\n                                    Toast.makeText(this@MainActivity, \"Error stopping streaming\", Toast.LENGTH_SHORT).show()\n                                }\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            },\n                            isTimerRunning = isTimerRunning,\n                            timerStartTimeMillis = timerStartTimeMillis,\n                            timerAccumulatedMillis = timerAccumulatedMillis,\n                            onViewResult = {\n                                Log.d(TAG, \"View Result clicked.\")\n                                Toast.makeText(this@MainActivity, \"View Result to be implemented\", Toast.LENGTH_SHORT).show()\n                            }\n                        )\n                        AppScreen.PATIENT_MAIN -> PatientMainScreen(\n                            onScanClick = {\n                                Log.d(TAG, \"PatientMainScreen: Disconnect and return to scan clicked.\")\n                                try {\n                                    writeDataControl(false)\n                                    disconnectGatt()\n                                    clearData()\n                                    scannedDevices.clear()\n                                    rssiMap.clear()\n                                    currentScreen = AppScreen.SCAN\n                                    scanInitiatedState = false\n                                } catch (e: Exception) {\n                                    Log.e(TAG, \"Error during disconnect: ${e.message}\")\n                                    Toast.makeText(this@MainActivity, \"Error disconnecting: ${e.message}\", Toast.LENGTH_SHORT).show()\n                                }\n                            },\n                            isDataStreamingEnabled = isDataStreamingEnabled,\n                            isDeviceReadyForControl = isDeviceReadyForControl,\n                            onStartStreaming = {\n                                Log.d(TAG, \"PatientMainScreen: START STREAMING clicked.\")\n                                currentScreen = AppScreen.GET_READY\n                            },\n                            onStopStreaming = {\n                                Log.d(TAG, \"PatientMainScreen: STOP STREAMING clicked.\")\n                                try {\n                                    writeDataControl(false)\n                                } catch (e: Exception) {\n                                    Log.e(TAG, \"Error stopping streaming: ${e.message}\")\n                                    Toast.makeText(this@MainActivity, \"Error stopping streaming\", Toast.LENGTH_SHORT).show()\n                                }\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            },\n                            isTimerRunning = isTimerRunning,\n                            timerStartTimeMillis = timerStartTimeMillis,\n                            timerAccumulatedMillis = timerAccumulatedMillis,\n                            onViewResult = {\n                                Log.d(TAG, \"PatientMainScreen: View Result clicked.\")\n                                Toast.makeText(this@MainActivity, \"View Result to be implemented\", Toast.LENGTH_SHORT).show()\n                            }\n                        )\n                        AppScreen.PATIENT_LIST -> PatientListScreen(\n                            patientDoctorLinks = patientDoctorLinks.filter { it.doctorUsername == currentUser?.username },\n                            onPatientClick = { patientUsername ->\n                                currentScreen = AppScreen.PATIENT_PROFILE\n                            },\n                            onApprovePatient = { patientUsername ->\n                                val link = patientDoctorLinks.find { it.patientUsername == patientUsername }\n                                if (link != null) {\n                                    patientDoctorLinks.remove(link)\n                                    patientDoctorLinks.add(link.copy(isApproved = true))\n                                    Toast.makeText(this@MainActivity, \"Patient $patientUsername approved.\", Toast.LENGTH_SHORT).show()\n                                }\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            }\n                        )\n                        AppScreen.PATIENT_PROFILE -> PatientProfileScreen(\n                            patientUsername = \"Placeholder\", // Update with selected patient\n                            onBack = {\n                                currentScreen = AppScreen.PATIENT_LIST\n                            },\n                            isDarkTheme = isDarkThemeEnabled,\n                            onToggleTheme = {\n                                coroutineScope.launch {\n                                    dataStore.edit { settings ->\n                                        settings[IS_DARK_MODE_KEY] = !isDarkThemeEnabled\n                                    }\n                                }\n                            }\n                        )\n                    }\n                }\n            }\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun requestBluetoothPermissions(callback: (Boolean) -> Unit) {\n        val permissionsToRequest = mutableListOf<String>()\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {\n            if (ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_SCAN) != PackageManager.PERMISSION_GRANTED) {\n                permissionsToRequest.add(Manifest.permission.BLUETOOTH_SCAN)\n            }\n            if (ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {\n                permissionsToRequest.add(Manifest.permission.BLUETOOTH_CONNECT)\n            }\n        } else {\n            if (ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH_ADMIN) != PackageManager.PERMISSION_GRANTED) {\n                permissionsToRequest.add(Manifest.permission.BLUETOOTH_ADMIN)\n            }\n            if (ContextCompat.checkSelfPermission(this, Manifest.permission.BLUETOOTH) != PackageManager.PERMISSION_GRANTED) {\n                permissionsToRequest.add(Manifest.permission.BLUETOOTH)\n            }\n        }\n\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n            permissionsToRequest.add(Manifest.permission.ACCESS_FINE_LOCATION)\n        }\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n            permissionsToRequest.add(Manifest.permission.ACCESS_COARSE_LOCATION)\n        }\n\n        if (permissionsToRequest.isNotEmpty()) {\n            Log.d(TAG, \"Requesting permissions: ${permissionsToRequest.joinToString()}\")\n            requestPermissionsLauncher.launch(permissionsToRequest.toTypedArray())\n        } else {\n            Log.d(TAG, \"All permissions granted.\")\n            checkBluetoothAndLocationStatus(callback)\n        }\n    }\n\n    private fun checkBluetoothAndLocationStatus(callback: (Boolean) -> Unit) {\n        Log.d(TAG, \"Checking Bluetooth and Location Status...\")\n        if (bluetoothAdapter == null) {\n            Log.e(TAG, \"BluetoothAdapter null.\")\n            Toast.makeText(this, \"Bluetooth not supported.\", Toast.LENGTH_LONG).show()\n            callback(false)\n            return\n        }\n\n        if (!bluetoothAdapter.isEnabled) {\n            Log.w(TAG, \"Bluetooth not enabled.\")\n            Toast.makeText(this, \"Please enable Bluetooth.\", Toast.LENGTH_SHORT).show()\n            val enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)\n            enableBluetoothLauncher.launch(enableBtIntent)\n            return\n        }\n\n        checkLocationServiceStatus(callback)\n    }\n\n    private fun checkLocationServiceStatus(callback: (Boolean) -> Unit) {\n        Log.d(TAG, \"Checking Location Service Status...\")\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager\n            val isLocationEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) ||\n                    locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)\n\n            if (!isLocationEnabled) {\n                Log.w(TAG, \"Location Services not enabled.\")\n                Toast.makeText(this, \"Please enable Location Services.\", Toast.LENGTH_LONG).show()\n                val intent = Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)\n                enableLocationLauncher.launch(intent)\n                return\n            }\n        }\n        Log.d(TAG, \"All pre-scan checks passed.\")\n        toggleScan()\n        callback(true)\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun toggleScan() = if (scanning) stopScan() else startScan()\n\n    @SuppressLint(\"MissingPermission\")\n    private fun startScan() {\n        Log.d(TAG, \"Starting BLE scan.\")\n        scannedDevices.clear()\n        rssiMap.clear()\n        bluetoothLeScanner = bluetoothAdapter.bluetoothLeScanner\n\n        val scanSettings = ScanSettings.Builder()\n            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)\n            .build()\n\n        bluetoothLeScanner?.startScan(null, scanSettings, scanCallback)\n        scanning = true\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun stopScan() {\n        Log.d(TAG, \"Stopping BLE scan.\")\n        bluetoothLeScanner?.stopScan(scanCallback)\n        scanning = false\n    }\n\n    private val scanCallback = object : ScanCallback() {\n        @SuppressLint(\"MissingPermission\")\n        override fun onScanResult(callbackType: Int, result: ScanResult?) {\n            result?.device?.let { device ->\n                val deviceName = device.name ?: \"Unknown Device\"\n                val deviceAddress = device.address\n                if (scannedDevices.none { it.address == deviceAddress }) {\n                    scannedDevices.add(ScannedDeviceInfo(deviceName, deviceAddress))\n                    Log.d(TAG, \"Found device: $deviceName (${deviceAddress}), RSSI: ${result.rssi}\")\n                }\n                rssiMap[deviceAddress] = result.rssi ?: 0\n            }\n        }\n        override fun onScanFailed(errorCode: Int) {\n            super.onScanFailed(errorCode)\n            Log.e(TAG, \"BLE Scan Failed: $errorCode\")\n            Toast.makeText(this@MainActivity, \"BLE Scan Failed: $errorCode\", Toast.LENGTH_LONG).show()\n            scanning = false\n            onScanAttemptResult?.invoke(false)\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun connectToDevice(deviceInfo: ScannedDeviceInfo) {\n        Log.d(TAG, \"Connecting to device: ${deviceInfo.address}\")\n        try {\n            val device = bluetoothAdapter.getRemoteDevice(deviceInfo.address)\n            connectedGatt = device.connectGatt(this, false, gattCallback)\n            isDeviceReadyForControl = false\n            timerAccumulatedMillis = 0L\n            isTimerRunning = false\n            timerStartTimeMillis = 0L\n\n            coroutineScope.launch {\n                val patient = Patient(\n                    name = deviceInfo.name ?: \"Unknown User\",\n                    age = 30,\n                    medicalHistory = \"N/A\",\n                    deviceAddress = deviceInfo.address\n                )\n                try {\n                    val createdPatient = patientApi.addPatient(patient)\n                    Log.d(TAG, \"Patient saved: ${createdPatient.id}\")\n                    runOnUiThread {\n                        Toast.makeText(this@MainActivity, \"Patient linked to device\", Toast.LENGTH_SHORT).show()\n                    }\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Error saving patient: ${e.message}\")\n                    runOnUiThread {\n                        Toast.makeText(this@MainActivity, \"Failed to link patient\", Toast.LENGTH_SHORT).show()\n                    }\n                }\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error connecting to device: ${e.message}\")\n            Toast.makeText(this, \"Error connecting to device.\", Toast.LENGTH_SHORT).show()\n        }\n    }\n\n\n\n    @SuppressLint(\"MissingPermission\")\n    private fun disconnectGatt() {\n        Log.d(TAG, \"Disconnecting GATT.\")\n        try {\n            if (isTimerRunning) {\n                val elapsed = System.currentTimeMillis() - timerStartTimeMillis\n                timerAccumulatedMillis += elapsed\n                isTimerRunning = false\n                timerStartTimeMillis = 0L\n                Log.d(TAG, \"Timer stopped. Accumulated: $timerAccumulatedMillis ms\")\n            }\n\n            connectedGatt?.apply {\n                disconnect()\n                close()\n            }\n            connectedGatt = null\n            controlCharacteristic = null\n            pNotifyCharacteristic = null\n            mainHandler.post {\n                isDataStreamingEnabled = false\n                isDeviceReadyForControl = false\n                isTimerRunning = false\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error during GATT disconnect: ${e.message}\")\n        }\n    }\n\n    private val gattCallback = object : BluetoothGattCallback() {\n        @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)\n        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {\n            Log.d(TAG, \"onConnectionStateChange: device=${gatt.device.address}, status=$status, newState=$newState\")\n            when (newState) {\n                BluetoothProfile.STATE_CONNECTED -> {\n                    Log.d(TAG, \"GATT connected to ${gatt.device.address}.\")\n                    try {\n                        val cacheRefreshed = refreshDeviceCache(gatt)\n                        Log.d(TAG, \"GATT cache refresh: $cacheRefreshed\")\n\n                        Handler(Looper.getMainLooper()).postDelayed({\n                            gatt.requestMtu(512)\n                            Handler(Looper.getMainLooper()).postDelayed({\n                                @SuppressLint(\"MissingPermission\")\n                                val discovered = gatt.discoverServices()\n                                Log.d(TAG, \"discoverServices: $discovered\")\n                                if (!discovered) {\n                                    Log.e(TAG, \"Failed to start service discovery\")\n                                    mainHandler.post { Toast.makeText(this@MainActivity, \"Failed to discover services\", Toast.LENGTH_SHORT).show() }\n                                    disconnectGatt()\n                                }\n                            }, 500)\n                        }, 200)\n                    } catch (e: Exception) {\n                        Log.e(TAG, \"Error during GATT setup: ${e.message}\")\n                        disconnectGatt()\n                    }\n                }\n                BluetoothProfile.STATE_DISCONNECTED -> {\n                    Log.d(TAG, \"GATT disconnected from ${gatt.device.address}\")\n                    mainHandler.post {\n                        Toast.makeText(this@MainActivity, \"Disconnected from device\", Toast.LENGTH_SHORT).show()\n                        isDataStreamingEnabled = false\n                        isDeviceReadyForControl = false\n                        if (isTimerRunning) {\n                            val elapsed = System.currentTimeMillis() - timerStartTimeMillis\n                            timerAccumulatedMillis += elapsed\n                            isTimerRunning = false\n                            timerStartTimeMillis = 0L\n                            Log.d(TAG, \"Timer stopped. Accumulated: $timerAccumulatedMillis ms\")\n                        }\n                    }\n                    disconnectGatt()\n                }\n            }\n            if (status != BluetoothGatt.GATT_SUCCESS) {\n                Log.e(TAG, \"GATT connection error: $status\")\n                mainHandler.post {\n                    Toast.makeText(this@MainActivity, \"Connection Error: $status\", Toast.LENGTH_LONG).show()\n                    disconnectGatt()\n                }\n            }\n        }\n\n        override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {\n            Log.d(TAG, \"onMtuChanged: mtu=$mtu, status=$status\")\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                Log.d(TAG, \"MTU updated to $mtu\")\n            } else {\n                Log.e(TAG, \"Failed to set MTU: $status\")\n            }\n        }\n\n        @SuppressLint(\"MissingPermission\")\n        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {\n            Log.d(TAG, \"onServicesDiscovered: status=$status\")\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                try {\n                    val service = gatt.getService(SERVICE_UUID)\n                    if (service == null) {\n                        Log.e(TAG, \"Glove Service not found!\")\n                        mainHandler.post { Toast.makeText(this@MainActivity, \"Glove Service not found!\", Toast.LENGTH_LONG).show() }\n                        disconnectGatt()\n                        return\n                    }\n                    Log.d(TAG, \"Glove Service found: ${service.uuid}\")\n\n                    val notifyChar = service.getCharacteristic(CHARACTERISTIC_NOTIFY_UUID)\n                    val writeChar = service.getCharacteristic(CHARACTERISTIC_WRITE_UUID)\n\n                    if (notifyChar == null) {\n                        Log.e(TAG, \"Notify Characteristic not found!\")\n                        mainHandler.post { Toast.makeText(this@MainActivity, \"Notify Characteristic not found!\", Toast.LENGTH_LONG).show() }\n                        disconnectGatt()\n                        return\n                    }\n                    Log.d(TAG, \"Notify Characteristic found: ${notifyChar.uuid}\")\n\n                    if (writeChar == null) {\n                        Log.e(TAG, \"Write Characteristic not found!\")\n                        mainHandler.post { Toast.makeText(this@MainActivity, \"Control Characteristic not found!\", Toast.LENGTH_LONG).show() }\n                        disconnectGatt()\n                        return\n                    }\n                    Log.d(TAG, \"Write Characteristic found: ${writeChar.uuid}\")\n\n                    pNotifyCharacteristic = notifyChar\n                    controlCharacteristic = writeChar\n\n                    val setNotifySuccess = gatt.setCharacteristicNotification(notifyChar, true)\n                    Log.d(TAG, \"setCharacteristicNotification: $setNotifySuccess\")\n\n                    val descriptor = notifyChar.getDescriptor(CLIENT_CHAR_CONFIG_UUID)\n                    if (descriptor == null) {\n                        Log.e(TAG, \"Client Characteristic Config Descriptor not found!\")\n                        mainHandler.post { Toast.makeText(this@MainActivity, \"Notification descriptor not found!\", Toast.LENGTH_LONG).show() }\n                        disconnectGatt()\n                        return\n                    }\n\n                    descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE\n                    val writeDescriptorSuccess = gatt.writeDescriptor(descriptor)\n                    Log.d(TAG, \"writeDescriptor: $writeDescriptorSuccess\")\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Error in onServicesDiscovered: ${e.message}\")\n                    disconnectGatt()\n                }\n            } else {\n                Log.e(TAG, \"Service discovery failed: $status\")\n                mainHandler.post { Toast.makeText(this@MainActivity, \"Service discovery failed: $status\", Toast.LENGTH_LONG).show() }\n                disconnectGatt()\n            }\n        }\n\n        @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)\n        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, value: ByteArray) {\n            if (characteristic.uuid == CHARACTERISTIC_NOTIFY_UUID) {\n                try {\n                    val receivedData = String(value, Charsets.UTF_8)\n                    buffer.append(receivedData)\n\n                    var startIndex = 0\n                    while (true) {\n                        val newlineIndex = buffer.indexOf('\\n', startIndex)\n                        if (newlineIndex == -1) break\n\n                        val line = buffer.substring(startIndex, newlineIndex).trim()\n                        if (line.isNotEmpty()) {\n                            processReceivedLine(line)\n                        }\n                        startIndex = newlineIndex + 1\n                    }\n\n                    if (startIndex > 0) {\n                        buffer.delete(0, startIndex)\n                    }\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Error processing characteristic change: ${e.message}\")\n                }\n            }\n        }\n\n        @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)\n        override fun onCharacteristicWrite(gatt: BluetoothGatt?, characteristic: BluetoothGattCharacteristic?, status: Int) {\n            if (characteristic?.uuid == CHARACTERISTIC_WRITE_UUID) {\n                if (status == BluetoothGatt.GATT_SUCCESS) {\n                    Log.d(TAG, \"Control Characteristic write successful\")\n                } else {\n                    Log.e(TAG, \"Control Characteristic write failed: $status\")\n                    mainHandler.post { Toast.makeText(this@MainActivity, \"Command send failed: $status\", Toast.LENGTH_SHORT).show() }\n                    isDataStreamingEnabled = false\n                }\n            }\n        }\n\n        @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)\n        override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {\n            if (descriptor.uuid == CLIENT_CHAR_CONFIG_UUID) {\n                if (status == BluetoothGatt.GATT_SUCCESS) {\n                    Log.d(TAG, \"Notification descriptor written successfully\")\n                    mainHandler.post {\n                        Toast.makeText(this@MainActivity, \"Notifications enabled.\", Toast.LENGTH_SHORT).show()\n                        isDeviceReadyForControl = true\n                    }\n                } else {\n                    Log.e(TAG, \"Failed to write notification descriptor: $status\")\n                    mainHandler.post { Toast.makeText(this@MainActivity, \"Failed to enable notifications.\", Toast.LENGTH_LONG).show() }\n                    disconnectGatt()\n                }\n            }\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun refreshDeviceCache(gatt: BluetoothGatt?): Boolean {\n        if (gatt == null) return false\n        try {\n            val localMethod = gatt.javaClass.getMethod(\"refresh\")\n            if (localMethod != null) {\n                val bool = localMethod.invoke(gatt) as Boolean\n                Log.d(TAG, \"refreshDeviceCache: $bool\")\n                return bool\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error refreshing device cache: ${e.message}\")\n        }\n        return false\n    }\n\n    private fun processReceivedLine(line: String) {\n        Log.d(TAG, \"processReceivedLine: $line\")\n        try {\n            val values = line.split(\",\").map { it.toFloatOrNull() ?: 0f }\n            if (values.size == 17) {\n                dataBuffer.add(values)\n                Log.d(TAG, \"Added data to buffer. Size: ${dataBuffer.size}\")\n            } else {\n                Log.w(TAG, \"Malformed data: $line (Expected 17, got ${values.size})\")\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error parsing data: ${e.message}, Line: $line\")\n        }\n    }\n\n    private fun processBufferedData() {\n        val dataToProcess = mutableListOf<List<Float>>()\n        synchronized(dataBuffer) {\n            dataToProcess.addAll(dataBuffer)\n            dataBuffer.clear()\n        }\n\n        if (dataToProcess.isEmpty()) {\n            Log.d(TAG, \"processBufferedData: No data.\")\n            return\n        }\n\n        Log.d(TAG, \"Processing ${dataToProcess.size} data points\")\n\n        var chartDataModified = false\n\n        for (values in dataToProcess) {\n            if (values.size != 17) {\n                Log.w(TAG, \"Skipping malformed data: $values (expected 17, got ${values.size})\")\n                continue\n            }\n\n            for (i in 0 until 7) {\n                val rawValue = when (i) {\n                    0 -> values[0] // BioAmp\n                    1 -> values[11] // AccelX\n                    2 -> values[12] // AccelY\n                    3 -> values[13] // AccelZ\n                    4 -> values[14] // GyroX\n                    5 -> values[15] // GyroY\n                    6 -> values[16] // GyroZ\n                    else -> 0f\n                }\n                imuBioMovingAverages[i].add(rawValue)\n                if (imuBioMovingAverages[i].size > windowSize) {\n                    imuBioMovingAverages[i].removeAt(0)\n                }\n                val filteredValue = imuBioMovingAverages[i].average().toFloat()\n                _imuBioEntriesInternal[i].add(Entry(xIndex, filteredValue))\n                if (_imuBioEntriesInternal[i].size > MAX_DATA_POINTS) {\n                    _imuBioEntriesInternal[i].removeAt(0)\n                }\n                chartDataModified = true\n            }\n\n            for (i in 0 until 5) {\n                val rawValue = values[i + 1] // Flex sensors (1-5)\n                flexMovingAverages[i].add(rawValue)\n                if (flexMovingAverages[i].size > windowSize) {\n                    flexMovingAverages[i].removeAt(0)\n                }\n                val filteredValue = flexMovingAverages[i].average().toFloat()\n                _flexEntriesInternal[i].add(Entry(xIndex, filteredValue))\n                if (_flexEntriesInternal[i].size > MAX_DATA_POINTS) {\n                    _flexEntriesInternal[i].removeAt(0)\n                }\n                chartDataModified = true\n            }\n\n            for (i in 0 until 5) {\n                val rawValue = values[i + 6] // FSR sensors (6-10)\n                fsrMovingAverages[i].add(rawValue)\n                if (fsrMovingAverages[i].size > windowSize) {\n                    fsrMovingAverages[i].removeAt(0)\n                }\n                val filteredValue = fsrMovingAverages[i].average().toFloat()\n                _fsrEntriesInternal[i].add(Entry(xIndex, filteredValue))\n                if (_fsrEntriesInternal[i].size > MAX_DATA_POINTS) {\n                    _fsrEntriesInternal[i].removeAt(0)\n                }\n                chartDataModified = true\n            }\n            xIndex += 1\n        }\n\n        if (chartDataModified) {\n            mainHandler.post {\n                try {\n                    for (i in 0 until 5) {\n                        fsrEntries[i] = _fsrEntriesInternal[i].toList()\n                    }\n                    for (i in 0 until 5) {\n                        flexEntries[i] = _flexEntriesInternal[i].toList()\n                    }\n                    for (i in 0 until 7) {\n                        imuBioEntries[i] = _imuBioEntriesInternal[i].toList()\n                    }\n                    dataUpdateTrigger++\n                    Log.d(TAG, \"Updated chart data. Trigger: $dataUpdateTrigger\")\n                } catch (e: Exception) {\n                    Log.e(TAG, \"Error updating chart entries: ${e.message}\")\n                }\n            }\n        }\n    }\n\n    private fun clearData() {\n        Log.d(TAG, \"Clearing chart data and timer\")\n        try {\n            _fsrEntriesInternal.forEach { it.clear() }\n            _flexEntriesInternal.forEach { it.clear() }\n            _imuBioEntriesInternal.forEach { it.clear() }\n\n            mainHandler.post {\n                for (i in 0 until 5) {\n                    fsrEntries[i] = emptyList()\n                }\n                for (i in 0 until 5) {\n                    flexEntries[i] = emptyList()\n                }\n                for (i in 0 until 7) {\n                    imuBioEntries[i] = emptyList()\n                }\n                dataUpdateTrigger++\n            }\n\n            fsrMovingAverages.forEach { it.clear() }\n            flexMovingAverages.forEach { it.clear() }\n            imuBioMovingAverages.forEach { it.clear() }\n            dataBuffer.clear()\n            xIndex = 0f\n\n            timerAccumulatedMillis = 0L\n            isTimerRunning = false\n            timerStartTimeMillis = 0L\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error clearing data: ${e.message}\")\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    private fun writeDataControl(enable: Boolean) {\n        val command = if (enable) \"START\" else \"STOP\"\n        Log.d(TAG, \"writeDataControl: $command. States: connectedGatt=${connectedGatt != null}, controlCharacteristic=${controlCharacteristic != null}, isDeviceReadyForControl=$isDeviceReadyForControl, isDataStreamingEnabled=$isDataStreamingEnabled, timerRunning=$isTimerRunning, accumulatedMillis=$timerAccumulatedMillis\")\n\n        try {\n            if (connectedGatt == null) {\n                Log.e(TAG, \"No GATT connection for $command.\")\n                mainHandler.post {\n                    Toast.makeText(this@MainActivity, \"Not connected to device.\", Toast.LENGTH_SHORT).show()\n                }\n                isDataStreamingEnabled = false\n                return\n            }\n\n            if (controlCharacteristic == null) {\n                Log.e(TAG, \"Control characteristic not found for $command.\")\n                mainHandler.post {\n                    Toast.makeText(this@MainActivity, \"Control characteristic unavailable.\", Toast.LENGTH_SHORT).show()\n                }\n                isDataStreamingEnabled = false\n                return\n            }\n\n            if (!isDeviceReadyForControl) {\n                Log.w(TAG, \"Device not ready for $command. Retrying in 500ms.\")\n                mainHandler.postDelayed({\n                    if (isDeviceReadyForControl && connectedGatt != null && controlCharacteristic != null) {\n                        Log.d(TAG, \"Retry writeDataControl for $command.\")\n                        writeDataControl(enable)\n                    } else {\n                        Log.e(TAG, \"Device still not ready after retry.\")\n                        mainHandler.post {\n                            Toast.makeText(this@MainActivity, \"Device not ready.\", Toast.LENGTH_SHORT).show()\n                        }\n                        isDataStreamingEnabled = false\n                    }\n                }, 500)\n                return\n            }\n\n            if (enable == isDataStreamingEnabled) {\n                Log.w(TAG, \"Command $command ignored. State unchanged.\")\n                return\n            }\n\n            controlCharacteristic?.value = command.toByteArray(Charsets.UTF_8)\n            val writeSuccess = connectedGatt?.writeCharacteristic(controlCharacteristic) ?: false\n            Log.d(TAG, \"Write for $command: $writeSuccess\")\n\n            if (writeSuccess) {\n                isDataStreamingEnabled = enable\n                Log.d(TAG, \"isDataStreamingEnabled set to $enable\")\n                if (enable && !isTimerRunning) {\n                    timerStartTimeMillis = System.currentTimeMillis()\n                    isTimerRunning = true\n                    Log.d(TAG, \"Timer started at $timerStartTimeMillis\")\n                } else if (!enable && isTimerRunning) {\n                    val elapsed = System.currentTimeMillis() - timerStartTimeMillis\n                    timerAccumulatedMillis += elapsed\n                    isTimerRunning = false\n                    timerStartTimeMillis = 0L\n                    Log.d(TAG, \"Timer stopped. Accumulated: $timerAccumulatedMillis ms\")\n                }\n            } else {\n                Log.e(TAG, \"Failed to initiate write for $command\")\n                mainHandler.post {\n                    Toast.makeText(this@MainActivity, \"Failed to send $command.\", Toast.LENGTH_SHORT).show()\n                }\n                isDataStreamingEnabled = false\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error in writeDataControl: ${e.message}\")\n            mainHandler.post {\n                Toast.makeText(this@MainActivity, \"Error sending command.\", Toast.LENGTH_SHORT).show()\n            }\n            isDataStreamingEnabled = false\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun SignInScreen(\n    onSignIn: (String, String) -> Unit,\n    onSignUpClick: () -> Unit,\n    isDarkTheme: Boolean,\n    onToggleTheme: () -> Unit\n) {\n    var username by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Sign In\", color = MaterialTheme.colorScheme.onPrimary) },\n                actions = {\n                    Row(\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(end = 8.dp)\n                    ) {\n                        Icon(\n                            imageVector = if (isDarkTheme) Icons.Default.DarkMode else Icons.Default.LightMode,\n                            contentDescription = if (isDarkTheme) \"Dark Mode\" else \"Light Mode\",\n                            tint = MaterialTheme.colorScheme.onPrimary\n                        )\n                        Spacer(Modifier.width(4.dp))\n                        Switch(\n                            checked = isDarkTheme,\n                            onCheckedChange = { onToggleTheme() },\n                            colors = SwitchDefaults.colors(\n                                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,\n                                uncheckedThumbColor = MaterialTheme.colorScheme.onPrimary,\n                                checkedTrackColor = MaterialTheme.colorScheme.secondary,\n                                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant\n                            )\n                        )\n                    }\n                },\n                colors = TopAppBarDefaults.mediumTopAppBarColors(\n                    containerColor = MaterialTheme.colorScheme.primary,\n                    titleContentColor = MaterialTheme.colorScheme.onPrimary\n                )\n            )\n        }\n    ) { padding ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(MaterialTheme.colorScheme.background)\n                .padding(padding)\n                .padding(16.dp),\n            verticalArrangement = Arrangement.Center,\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            TextField(\n                value = username,\n                onValueChange = { username = it },\n                label = { Text(\"Username\") },\n                modifier = Modifier.fillMaxWidth(),\n                colors = TextFieldDefaults.colors(\n                    focusedContainerColor = MaterialTheme.colorScheme.surface,\n                    unfocusedContainerColor = MaterialTheme.colorScheme.surface,\n                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,\n                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)\n                )\n            )\n            Spacer(Modifier.height(16.dp))\n            TextField(\n                value = password,\n                onValueChange = { password = it },\n                label = { Text(\"Password\") },\n                modifier = Modifier.fillMaxWidth(),\n                visualTransformation = PasswordVisualTransformation(),\n                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),\n                colors = TextFieldDefaults.colors(\n                    focusedContainerColor = MaterialTheme.colorScheme.surface,\n                    unfocusedContainerColor = MaterialTheme.colorScheme.surface,\n                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,\n                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)\n                )\n            )\n            Spacer(Modifier.height(24.dp))\n            Button(\n                onClick = { onSignIn(username, password) },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(52.dp),\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = MaterialTheme.colorScheme.primary,\n                    contentColor = MaterialTheme.colorScheme.onPrimary\n                ),\n                shape = MaterialTheme.shapes.medium\n            ) {\n                Text(\"Sign In\")\n            }\n            Spacer(Modifier.height(16.dp))\n            TextButton(onClick = onSignUpClick) {\n                Text(\"Don't have an account? Sign Up\", color = MaterialTheme.colorScheme.primary)\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun SignUpScreen(\n    onSignUp: (String, String, UserRole, String?) -> Unit,\n    onBackToSignIn: () -> Unit,\n    isDarkTheme: Boolean,\n    onToggleTheme: () -> Unit\n) {\n    var username by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n    var role by remember { mutableStateOf(UserRole.PATIENT) }\n    var doctorUsername by remember { mutableStateOf(\"\") }\n    var expanded by remember { mutableStateOf(false) }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Sign Up\", color = MaterialTheme.colorScheme.onPrimary) },\n                actions = {\n                    Row(\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(end = 8.dp)\n                    ) {\n                        Icon(\n                            imageVector = if (isDarkTheme) Icons.Default.DarkMode else Icons.Default.LightMode,\n                            contentDescription = if (isDarkTheme) \"Dark Mode\" else \"Light Mode\",\n                            tint = MaterialTheme.colorScheme.onPrimary\n                        )\n                        Spacer(Modifier.width(4.dp))\n                        Switch(\n                            checked = isDarkTheme,\n                            onCheckedChange = { onToggleTheme() },\n                            colors = SwitchDefaults.colors(\n                                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,\n                                uncheckedThumbColor = MaterialTheme.colorScheme.onPrimary,\n                                checkedTrackColor = MaterialTheme.colorScheme.secondary,\n                                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant\n                            )\n                        )\n                    }\n                },\n                colors = TopAppBarDefaults.mediumTopAppBarColors(\n                    containerColor = MaterialTheme.colorScheme.primary,\n                    titleContentColor = MaterialTheme.colorScheme.onPrimary\n                )\n            )\n        }\n    ) { padding ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(MaterialTheme.colorScheme.background)\n                .padding(padding)\n                .padding(16.dp),\n            verticalArrangement = Arrangement.Center,\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            TextField(\n                value = username,\n                onValueChange = { username = it },\n                label = { Text(\"Username\") },\n                modifier = Modifier.fillMaxWidth(),\n                colors = TextFieldDefaults.colors(\n                    focusedContainerColor = MaterialTheme.colorScheme.surface,\n                    unfocusedContainerColor = MaterialTheme.colorScheme.surface,\n                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,\n                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)\n                )\n            )\n            Spacer(Modifier.height(16.dp))\n            TextField(\n                value = password,\n                onValueChange = { password = it },\n                label = { Text(\"Password\") },\n                modifier = Modifier.fillMaxWidth(),\n                visualTransformation = PasswordVisualTransformation(),\n                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),\n                colors = TextFieldDefaults.colors(\n                    focusedContainerColor = MaterialTheme.colorScheme.surface,\n                    unfocusedContainerColor = MaterialTheme.colorScheme.surface,\n                    focusedIndicatorColor = MaterialTheme.colorScheme.primary,\n                    unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)\n                )\n            )\n            Spacer(Modifier.height(16.dp))\n            Box(modifier = Modifier.fillMaxWidth()) {\n                OutlinedTextField(\n                    value = role.name,\n                    onValueChange = {},\n                    label = { Text(\"Role\") },\n                    modifier = Modifier.fillMaxWidth(),\n                    readOnly = true,\n                    trailingIcon = {\n                        IconButton(onClick = { expanded = true }) {\n                            Icon(Icons.Default.ArrowDropDown, contentDescription = \"Select Role\")\n                        }\n                    },\n                    colors = TextFieldDefaults.colors(\n                        focusedContainerColor = MaterialTheme.colorScheme.surface,\n                        unfocusedContainerColor = MaterialTheme.colorScheme.surface,\n                        focusedIndicatorColor = MaterialTheme.colorScheme.primary,\n                        unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)\n                    )\n                )\n                DropdownMenu(\n                    expanded = expanded,\n                    onDismissRequest = { expanded = false },\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    UserRole.values().forEach { userRole ->\n                        DropdownMenuItem(\n                            text = { Text(userRole.name) },\n                            onClick = {\n                                role = userRole\n                                expanded = false\n                            }\n                        )\n                    }\n                }\n            }\n            if (role == UserRole.PATIENT) {\n                Spacer(Modifier.height(16.dp))\n                TextField(\n                    value = doctorUsername,\n                    onValueChange = { doctorUsername = it },\n                    label = { Text(\"Doctor's Username\") },\n                    modifier = Modifier.fillMaxWidth(),\n                    colors = TextFieldDefaults.colors(\n                        focusedContainerColor = MaterialTheme.colorScheme.surface,\n                        unfocusedContainerColor = MaterialTheme.colorScheme.surface,\n                        focusedIndicatorColor = MaterialTheme.colorScheme.primary,\n                        unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)\n                    )\n                )\n            }\n            Spacer(Modifier.height(24.dp))\n            Button(\n                onClick = {\n                    val doctor = if (role == UserRole.PATIENT && doctorUsername.isNotBlank()) doctorUsername else null\n                    onSignUp(username, password, role, doctor)\n                },\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(52.dp),\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = MaterialTheme.colorScheme.primary,\n                    contentColor = MaterialTheme.colorScheme.onPrimary\n                ),\n                shape = MaterialTheme.shapes.medium\n            ) {\n                Text(\"Sign Up\")\n            }\n            Spacer(Modifier.height(16.dp))\n            TextButton(onClick = onBackToSignIn) {\n                Text(\"Already have an account? Sign In\", color = MaterialTheme.colorScheme.primary)\n            }\n        }\n    }\n}",
                    "language": "kotlin"
                },
                "codebaseEnabled": true
            },
            "createdAt": 1750331560139,
            "isInternal": false,
            "rawContent": {
                "type": "doc",
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "command",
                                "attrs": {
                                    "label": "fix"
                                },
                                "content": [
                                    {
                                        "type": "text",
                                        "text": "/fix"
                                    }
                                ]
                            },
                            {
                                "type": "codeBlock",
                                "attrs": {
                                    "language": "kotlin"
                                },
                                "content": [
                                    {
                                        "type": "text",
                                        "text": "PatientProfileScreen(\n                            patientUsername = \"Placeholder\", // Update with selected patient\n                            onBack = {\n                                currentScreen = AppScreen.PATIENT_LIST"
                                    }
                                ]
                            },
                            {
                                "type": "text",
                                "text": "Unresolved reference 'PatientProfileScreen'."
                            }
                        ]
                    }
                ]
            }
        },
        {
            "id": "4f0db52b-7e9d-4e84-a466-ab9ceb6787c9",
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "I can see that `PatientProfileScreen` is not defined in your code. Let me first examine the current file structure to understand how other screens are implemented, and then create the missing `PatientProfileScreen` composable."
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01XkmFSZuZWvCQaDK1RUfRNS",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/MainActivity.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\MainActivity.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Now let me look for the AppScreen enum to understand what screens are defined, and also look for other screen composables to understand the pattern:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_016W1jHwiY3qm4xt2Pfo166C",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01MPTHLNx413XGqkvkRxCG68",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/AppScreen.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\AppScreen.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Now let me find where other screen composables are defined to understand the pattern:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_013U3xhptjGtG9bcDmK8RfYk",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me search for screen composables more broadly:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01KjzrwgiNxpTdoSHYBgxArH",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_015HD1KjbYeXkJqykw2fYozN",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\ScannedDeviceInfo.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me search for PatientListScreen specifically:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01Q8wGcTPVN9c3tj1FpcBoDZ",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "It seems like PatientListScreen is being called but not defined. Let me search for where screen composables are defined:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01ScUXpoajvFEWBBjWnQdMqY",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me view the SignInScreen and other screen composables in MainActivity.kt to understand the pattern:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_012BWTicVyPVc5vkk621145Q",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/MainActivity.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\MainActivity.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me search for more screen composables. Since PatientListScreen is missing, I need to find where it should be defined or create it:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01DkbYDff2Rq396FCCfiAv1q",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me look at MainScreen in ScannedDeviceInfo.kt to understand the pattern better:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01DJYGFjWStFNm2sfkK32DB9",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\ScannedDeviceInfo.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Now let me check if PatientListScreen exists in the ScannedDeviceInfo.kt file:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_017PhhjcgSofDJEVUiJ91SD9",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "The PatientListScreen composable is missing. Let me also check if PatientProfileScreen exists:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01RnUyjYkbs3ragLQLYMtWMQ",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Both PatientListScreen and PatientProfileScreen are missing. I need to create both composables. Let me check what parameters are passed to PatientListScreen first to understand the expected interface:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01NPDUFYEcmwifxxDr22R7GC",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/MainActivity.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\MainActivity.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Now I understand the interfaces needed. Let me create both missing composables. I'll add them to the ScannedDeviceInfo.kt file where other screen composables are defined:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01M3HKpFZfNQ7C4qKpiSA21e",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\ScannedDeviceInfo.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me find the end of the file to add the new composables:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_017Z4uXP6XU2vSRJhvzAVQBs",
                    "statusText": "Viewed file",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\ScannedDeviceInfo.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Now I'll add the missing PatientListScreen and PatientProfileScreen composables at the end of the file:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01JEmUhs23CnzQwJMcb1XBZJ",
                    "statusText": "Change generated",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt",
                                "fsPath": "C:\\Users\\abhi\\AndroidStudioProjects\\Gloveapp\\app\\src\\main\\java\\com\\example\\gloveapp\\ScannedDeviceInfo.kt"
                            }
                        ]
                    },
                    "isHidden": false
                },
                {
                    "type": "codeHunk",
                    "lineBasedDiff": "--- app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt\n+++ app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt\n@@ -1303,3 +1303,272 @@\n         )\n     }\n }\n+\n+@OptIn(ExperimentalMaterial3Api::class)\n+@Composable\n+fun PatientListScreen(\n+    patientDoctorLinks: List<PatientDoctorLink>,\n+    onPatientClick: (String) -> Unit,\n+    onApprovePatient: (String) -> Unit,\n+    isDarkTheme: Boolean,\n+    onToggleTheme: () -> Unit\n+) {\n+    Scaffold(\n+        topBar = {\n+            TopAppBar(\n+                title = { Text(\"Patient List\", color = MaterialTheme.colorScheme.onPrimary) },\n+                actions = {\n+                    Row(\n+                        verticalAlignment = Alignment.CenterVertically,\n+                        modifier = Modifier.padding(end = 8.dp)\n+                    ) {\n+                        Icon(\n+                            imageVector = if (isDarkTheme) Icons.Default.DarkMode else Icons.Default.LightMode,\n+                            contentDescription = if (isDarkTheme) \"Dark Mode\" else \"Light Mode\",\n+                            tint = MaterialTheme.colorScheme.onPrimary\n+                        )\n+                        Spacer(Modifier.width(4.dp))\n+                        Switch(\n+                            checked = isDarkTheme,\n+                            onCheckedChange = { onToggleTheme() },\n+                            colors = SwitchDefaults.colors(\n+                                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,\n+                                uncheckedThumbColor = MaterialTheme.colorScheme.onPrimary,\n+                                checkedTrackColor = MaterialTheme.colorScheme.secondary,\n+                                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant\n+                            )\n+                        )\n+                    }\n+                },\n+                colors = TopAppBarDefaults.mediumTopAppBarColors(\n+                    containerColor = MaterialTheme.colorScheme.primary,\n+                    titleContentColor = MaterialTheme.colorScheme.onPrimary\n+                )\n+            )\n+        }\n+    ) { padding ->\n+        LazyColumn(\n+            modifier = Modifier\n+                .fillMaxSize()\n+                .background(MaterialTheme.colorScheme.background)\n+                .padding(padding)\n+                .padding(16.dp),\n+            verticalArrangement = Arrangement.spacedBy(8.dp)\n+        ) {\n+            if (patientDoctorLinks.isEmpty()) {\n+                item {\n+                    Card(\n+                        modifier = Modifier.fillMaxWidth(),\n+                        colors = CardDefaults.cardColors(\n+                            containerColor = MaterialTheme.colorScheme.surfaceVariant\n+                        )\n+                    ) {\n+                        Text(\n+                            text = \"No patients found\",\n+                            style = MaterialTheme.typography.bodyLarge,\n+                            color = MaterialTheme.colorScheme.onSurfaceVariant,\n+                            modifier = Modifier.padding(16.dp),\n+                            textAlign = TextAlign.Center\n+                        )\n+                    }\n+                }\n+            } else {\n+                items(patientDoctorLinks) { link ->\n+                    Card(\n+                        modifier = Modifier\n+                            .fillMaxWidth()\n+                            .clickable { onPatientClick(link.patientUsername) },\n+                        colors = CardDefaults.cardColors(\n+                            containerColor = MaterialTheme.colorScheme.surface\n+                        ),\n+                        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n+                    ) {\n+                        Row(\n+                            modifier = Modifier\n+                                .fillMaxWidth()\n+                                .padding(16.dp),\n+                            horizontalArrangement = Arrangement.SpaceBetween,\n+                            verticalAlignment = Alignment.CenterVertically\n+                        ) {\n+                            Column(\n+                                modifier = Modifier.weight(1f)\n+                            ) {\n+                                Text(\n+                                    text = link.patientUsername,\n+                                    style = MaterialTheme.typography.titleMedium,\n+                                    color = MaterialTheme.colorScheme.onSurface\n+                                )\n+                                Spacer(modifier = Modifier.height(4.dp))\n+                                Text(\n+                                    text = if (link.isApproved) \"Approved\" else \"Pending Approval\",\n+                                    style = MaterialTheme.typography.bodyMedium,\n+                                    color = if (link.isApproved) \n+                                        MaterialTheme.colorScheme.primary \n+                                    else \n+                                        MaterialTheme.colorScheme.error\n+                                )\n+                            }\n+                            if (!link.isApproved) {\n+                                Button(\n+                                    onClick = { onApprovePatient(link.patientUsername) },\n+                                    colors = ButtonDefaults.buttonColors(\n+                                        containerColor = MaterialTheme.colorScheme.primary,\n+                                        contentColor = MaterialTheme.colorScheme.onPrimary\n+                                    )\n+                                ) {\n+                                    Text(\"Approve\")\n+                                }\n+                            } else {\n+                                Icon(\n+                                    imageVector = Icons.Default.CheckCircle,\n+                                    contentDescription = \"Approved\",\n+                                    tint = MaterialTheme.colorScheme.primary\n+                                )\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+@OptIn(ExperimentalMaterial3Api::class)\n+@Composable\n+fun PatientProfileScreen(\n+    patientUsername: String,\n+    onBack: () -> Unit,\n+    isDarkTheme: Boolean,\n+    onToggleTheme: () -> Unit\n+) {\n+    Scaffold(\n+        topBar = {\n+            TopAppBar(\n+                title = { Text(\"Patient Profile\", color = MaterialTheme.colorScheme.onPrimary) },\n+                navigationIcon = {\n+                    IconButton(onClick = onBack) {\n+                        Icon(\n+                            Icons.Default.ArrowBack,\n+                            contentDescription = \"Back\",\n+                            tint = MaterialTheme.colorScheme.onPrimary\n+                        )\n+                    }\n+                },\n+                actions = {\n+                    Row(\n+                        verticalAlignment = Alignment.CenterVertically,\n+                        modifier = Modifier.padding(end = 8.dp)\n+                    ) {\n+                        Icon(\n+                            imageVector = if (isDarkTheme) Icons.Default.DarkMode else Icons.Default.LightMode,\n+                            contentDescription = if (isDarkTheme) \"Dark Mode\" else \"Light Mode\",\n+                            tint = MaterialTheme.colorScheme.onPrimary\n+                        )\n+                        Spacer(Modifier.width(4.dp))\n+                        Switch(\n+                            checked = isDarkTheme,\n+                            onCheckedChange = { onToggleTheme() },\n+                            colors = SwitchDefaults.colors(\n+                                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,\n+                                uncheckedThumbColor = MaterialTheme.colorScheme.onPrimary,\n+                                checkedTrackColor = MaterialTheme.colorScheme.secondary,\n+                                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant\n+                            )\n+                        )\n+                    }\n+                },\n+                colors = TopAppBarDefaults.mediumTopAppBarColors(\n+                    containerColor = MaterialTheme.colorScheme.primary,\n+                    titleContentColor = MaterialTheme.colorScheme.onPrimary\n+                )\n+            )\n+        }\n+    ) { padding ->\n+        Column(\n+            modifier = Modifier\n+                .fillMaxSize()\n+                .background(MaterialTheme.colorScheme.background)\n+                .padding(padding)\n+                .padding(16.dp),\n+            verticalArrangement = Arrangement.spacedBy(16.dp)\n+        ) {\n+            Card(\n+                modifier = Modifier.fillMaxWidth(),\n+                colors = CardDefaults.cardColors(\n+                    containerColor = MaterialTheme.colorScheme.surface\n+                ),\n+                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n+            ) {\n+                Column(\n+                    modifier = Modifier.padding(16.dp)\n+                ) {\n+                    Text(\n+                        text = \"Patient Information\",\n+                        style = MaterialTheme.typography.titleLarge,\n+                        color = MaterialTheme.colorScheme.onSurface\n+                    )\n+                    Spacer(modifier = Modifier.height(8.dp))\n+                    Text(\n+                        text = \"Username: $patientUsername\",\n+                        style = MaterialTheme.typography.bodyLarge,\n+                        color = MaterialTheme.colorScheme.onSurface\n+                    )\n+                    Spacer(modifier = Modifier.height(4.dp))\n+                    Text(\n+                        text = \"Status: Active\",\n+                        style = MaterialTheme.typography.bodyMedium,\n+                        color = MaterialTheme.colorScheme.primary\n+                    )\n+                }\n+            }\n+            \n+            Card(\n+                modifier = Modifier.fillMaxWidth(),\n+                colors = CardDefaults.cardColors(\n+                    containerColor = MaterialTheme.colorScheme.surface\n+                ),\n+                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n+            ) {\n+                Column(\n+                    modifier = Modifier.padding(16.dp)\n+                ) {\n+                    Text(\n+                        text = \"Medical History\",\n+                        style = MaterialTheme.typography.titleMedium,\n+                        color = MaterialTheme.colorScheme.onSurface\n+                    )\n+                    Spacer(modifier = Modifier.height(8.dp))\n+                    Text(\n+                        text = \"Medical history details would be displayed here.\",\n+                        style = MaterialTheme.typography.bodyMedium,\n+                        color = MaterialTheme.colorScheme.onSurfaceVariant\n+                    )\n+                }\n+            }\n+            \n+            Card(\n+                modifier = Modifier.fillMaxWidth(),\n+                colors = CardDefaults.cardColors(\n+                    containerColor = MaterialTheme.colorScheme.surface\n+                ),\n+                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n+            ) {\n+                Column(\n+                    modifier = Modifier.padding(16.dp)\n+                ) {\n+                    Text(\n+                        text = \"Recent Sessions\",\n+                        style = MaterialTheme.typography.titleMedium,\n+                        color = MaterialTheme.colorScheme.onSurface\n+                    )\n+                    Spacer(modifier = Modifier.height(8.dp))\n+                    Text(\n+                        text = \"No recent sessions available.\",\n+                        style = MaterialTheme.typography.bodyMedium,\n+                        color = MaterialTheme.colorScheme.onSurfaceVariant\n+                    )\n+                }\n+            }\n+        }\n+    }\n+}",
                    "refToolCallId": "toolu_01JEmUhs23CnzQwJMcb1XBZJ"
                },
                {
                    "type": "text",
                    "text": "Now I need to also import the `PatientDoctorLink` data class into the ScannedDeviceInfo.kt file since it's being used in the PatientListScreen function. However, I notice that `PatientDoctorLink` is defined in MainActivity.kt. Let me check if there are any import issues we need to address:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_016haiZKrPHfNfRKwLvhjjAo",
                    "status": "IN_PROGRESS",
                    "isHidden": true,
                    "localResult": "{\"status\":\"CANCELLED\",\"exitCode\":null,\"output\":\"Cancelled by user\"}"
                },
                {
                    "type": "codePatch",
                    "diffs": [
                        {
                            "path": "app/src/main/java/com/example/gloveapp/ScannedDeviceInfo.kt",
                            "patch": "@@ -51132,28 +51132,11916 @@\n Theme = %7B%7D%0A        )%0A    %7D%0A%7D\n+%0A%0A@OptIn(ExperimentalMaterial3Api::class)%0A@Composable%0Afun PatientListScreen(%0A    patientDoctorLinks: List%3CPatientDoctorLink%3E,%0A    onPatientClick: (String) -%3E Unit,%0A    onApprovePatient: (String) -%3E Unit,%0A    isDarkTheme: Boolean,%0A    onToggleTheme: () -%3E Unit%0A) %7B%0A    Scaffold(%0A        topBar = %7B%0A            TopAppBar(%0A                title = %7B Text(%22Patient List%22, color = MaterialTheme.colorScheme.onPrimary) %7D,%0A                actions = %7B%0A                    Row(%0A                        verticalAlignment = Alignment.CenterVertically,%0A                        modifier = Modifier.padding(end = 8.dp)%0A                    ) %7B%0A                        Icon(%0A                            imageVector = if (isDarkTheme) Icons.Default.DarkMode else Icons.Default.LightMode,%0A                            contentDescription = if (isDarkTheme) %22Dark Mode%22 else %22Light Mode%22,%0A                            tint = MaterialTheme.colorScheme.onPrimary%0A                        )%0A                        Spacer(Modifier.width(4.dp))%0A                        Switch(%0A                            checked = isDarkTheme,%0A                            onCheckedChange = %7B onToggleTheme() %7D,%0A                            colors = SwitchDefaults.colors(%0A                                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,%0A                                uncheckedThumbColor = MaterialTheme.colorScheme.onPrimary,%0A                                checkedTrackColor = MaterialTheme.colorScheme.secondary,%0A                                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant%0A                            )%0A                        )%0A                    %7D%0A                %7D,%0A                colors = TopAppBarDefaults.mediumTopAppBarColors(%0A                    containerColor = MaterialTheme.colorScheme.primary,%0A                    titleContentColor = MaterialTheme.colorScheme.onPrimary%0A                )%0A            )%0A        %7D%0A    ) %7B padding -%3E%0A        LazyColumn(%0A            modifier = Modifier%0A                .fillMaxSize()%0A                .background(MaterialTheme.colorScheme.background)%0A                .padding(padding)%0A                .padding(16.dp),%0A            verticalArrangement = Arrangement.spacedBy(8.dp)%0A        ) %7B%0A            if (patientDoctorLinks.isEmpty()) %7B%0A                item %7B%0A                    Card(%0A                        modifier = Modifier.fillMaxWidth(),%0A                        colors = CardDefaults.cardColors(%0A                            containerColor = MaterialTheme.colorScheme.surfaceVariant%0A                        )%0A                    ) %7B%0A                        Text(%0A                            text = %22No patients found%22,%0A                            style = MaterialTheme.typography.bodyLarge,%0A                            color = MaterialTheme.colorScheme.onSurfaceVariant,%0A                            modifier = Modifier.padding(16.dp),%0A                            textAlign = TextAlign.Center%0A                        )%0A                    %7D%0A                %7D%0A            %7D else %7B%0A                items(patientDoctorLinks) %7B link -%3E%0A                    Card(%0A                        modifier = Modifier%0A                            .fillMaxWidth()%0A                            .clickable %7B onPatientClick(link.patientUsername) %7D,%0A                        colors = CardDefaults.cardColors(%0A                            containerColor = MaterialTheme.colorScheme.surface%0A                        ),%0A                        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)%0A                    ) %7B%0A                        Row(%0A                            modifier = Modifier%0A                                .fillMaxWidth()%0A                                .padding(16.dp),%0A                            horizontalArrangement = Arrangement.SpaceBetween,%0A                            verticalAlignment = Alignment.CenterVertically%0A                        ) %7B%0A                            Column(%0A                                modifier = Modifier.weight(1f)%0A                            ) %7B%0A                                Text(%0A                                    text = link.patientUsername,%0A                                    style = MaterialTheme.typography.titleMedium,%0A                                    color = MaterialTheme.colorScheme.onSurface%0A                                )%0A                                Spacer(modifier = Modifier.height(4.dp))%0A                                Text(%0A                                    text = if (link.isApproved) %22Approved%22 else %22Pending Approval%22,%0A                                    style = MaterialTheme.typography.bodyMedium,%0A                                    color = if (link.isApproved) %0A                                        MaterialTheme.colorScheme.primary %0A                                    else %0A                                        MaterialTheme.colorScheme.error%0A                                )%0A                            %7D%0A                            if (!link.isApproved) %7B%0A                                Button(%0A                                    onClick = %7B onApprovePatient(link.patientUsername) %7D,%0A                                    colors = ButtonDefaults.buttonColors(%0A                                        containerColor = MaterialTheme.colorScheme.primary,%0A                                        contentColor = MaterialTheme.colorScheme.onPrimary%0A                                    )%0A                                ) %7B%0A                                    Text(%22Approve%22)%0A                                %7D%0A                            %7D else %7B%0A                                Icon(%0A                                    imageVector = Icons.Default.CheckCircle,%0A                                    contentDescription = %22Approved%22,%0A                                    tint = MaterialTheme.colorScheme.primary%0A                                )%0A                            %7D%0A                        %7D%0A                    %7D%0A                %7D%0A            %7D%0A        %7D%0A    %7D%0A%7D%0A%0A@OptIn(ExperimentalMaterial3Api::class)%0A@Composable%0Afun PatientProfileScreen(%0A    patientUsername: String,%0A    onBack: () -%3E Unit,%0A    isDarkTheme: Boolean,%0A    onToggleTheme: () -%3E Unit%0A) %7B%0A    Scaffold(%0A        topBar = %7B%0A            TopAppBar(%0A                title = %7B Text(%22Patient Profile%22, color = MaterialTheme.colorScheme.onPrimary) %7D,%0A                navigationIcon = %7B%0A                    IconButton(onClick = onBack) %7B%0A                        Icon(%0A                            Icons.Default.ArrowBack,%0A                            contentDescription = %22Back%22,%0A                            tint = MaterialTheme.colorScheme.onPrimary%0A                        )%0A                    %7D%0A                %7D,%0A                actions = %7B%0A                    Row(%0A                        verticalAlignment = Alignment.CenterVertically,%0A                        modifier = Modifier.padding(end = 8.dp)%0A                    ) %7B%0A                        Icon(%0A                            imageVector = if (isDarkTheme) Icons.Default.DarkMode else Icons.Default.LightMode,%0A                            contentDescription = if (isDarkTheme) %22Dark Mode%22 else %22Light Mode%22,%0A                            tint = MaterialTheme.colorScheme.onPrimary%0A                        )%0A                        Spacer(Modifier.width(4.dp))%0A                        Switch(%0A                            checked = isDarkTheme,%0A                            onCheckedChange = %7B onToggleTheme() %7D,%0A                            colors = SwitchDefaults.colors(%0A                                checkedThumbColor = MaterialTheme.colorScheme.onPrimary,%0A                                uncheckedThumbColor = MaterialTheme.colorScheme.onPrimary,%0A                                checkedTrackColor = MaterialTheme.colorScheme.secondary,%0A                                uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant%0A                            )%0A                        )%0A                    %7D%0A                %7D,%0A                colors = TopAppBarDefaults.mediumTopAppBarColors(%0A                    containerColor = MaterialTheme.colorScheme.primary,%0A                    titleContentColor = MaterialTheme.colorScheme.onPrimary%0A                )%0A            )%0A        %7D%0A    ) %7B padding -%3E%0A        Column(%0A            modifier = Modifier%0A                .fillMaxSize()%0A                .background(MaterialTheme.colorScheme.background)%0A                .padding(padding)%0A                .padding(16.dp),%0A            verticalArrangement = Arrangement.spacedBy(16.dp)%0A        ) %7B%0A            Card(%0A                modifier = Modifier.fillMaxWidth(),%0A                colors = CardDefaults.cardColors(%0A                    containerColor = MaterialTheme.colorScheme.surface%0A                ),%0A                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)%0A            ) %7B%0A                Column(%0A                    modifier = Modifier.padding(16.dp)%0A                ) %7B%0A                    Text(%0A                        text = %22Patient Information%22,%0A                        style = MaterialTheme.typography.titleLarge,%0A                        color = MaterialTheme.colorScheme.onSurface%0A                    )%0A                    Spacer(modifier = Modifier.height(8.dp))%0A                    Text(%0A                        text = %22Username: $patientUsername%22,%0A                        style = MaterialTheme.typography.bodyLarge,%0A                        color = MaterialTheme.colorScheme.onSurface%0A                    )%0A                    Spacer(modifier = Modifier.height(4.dp))%0A                    Text(%0A                        text = %22Status: Active%22,%0A                        style = MaterialTheme.typography.bodyMedium,%0A                        color = MaterialTheme.colorScheme.primary%0A                    )%0A                %7D%0A            %7D%0A            %0A            Card(%0A                modifier = Modifier.fillMaxWidth(),%0A                colors = CardDefaults.cardColors(%0A                    containerColor = MaterialTheme.colorScheme.surface%0A                ),%0A                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)%0A            ) %7B%0A                Column(%0A                    modifier = Modifier.padding(16.dp)%0A                ) %7B%0A                    Text(%0A                        text = %22Medical History%22,%0A                        style = MaterialTheme.typography.titleMedium,%0A                        color = MaterialTheme.colorScheme.onSurface%0A                    )%0A                    Spacer(modifier = Modifier.height(8.dp))%0A                    Text(%0A                        text = %22Medical history details would be displayed here.%22,%0A                        style = MaterialTheme.typography.bodyMedium,%0A                        color = MaterialTheme.colorScheme.onSurfaceVariant%0A                    )%0A                %7D%0A            %7D%0A            %0A            Card(%0A                modifier = Modifier.fillMaxWidth(),%0A                colors = CardDefaults.cardColors(%0A                    containerColor = MaterialTheme.colorScheme.surface%0A                ),%0A                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)%0A            ) %7B%0A                Column(%0A                    modifier = Modifier.padding(16.dp)%0A                ) %7B%0A                    Text(%0A                        text = %22Recent Sessions%22,%0A                        style = MaterialTheme.typography.titleMedium,%0A                        color = MaterialTheme.colorScheme.onSurface%0A                    )%0A                    Spacer(modifier = Modifier.height(8.dp))%0A                    Text(%0A                        text = %22No recent sessions available.%22,%0A                        style = MaterialTheme.typography.bodyMedium,%0A                        color = MaterialTheme.colorScheme.onSurfaceVariant%0A                    )%0A                %7D%0A            %7D%0A        %7D%0A    %7D%0A%7D\n",
                            "isNew": false,
                            "isApplied": true
                        }
                    ]
                },
                {
                    "type": "shellCommand",
                    "command": "cd \"C:/Users/abhi/AndroidStudioProjects/Gloveapp\"; ./gradlew build",
                    "id": "252d0ae0-45eb-4fa6-85e2-bdeb64d15681",
                    "status": "CANCELLED",
                    "toolCallId": "toolu_016haiZKrPHfNfRKwLvhjjAo",
                    "commandsRequiringConfirmation": [
                        {
                            "name": "gradlew",
                            "arguments": [
                                "build"
                            ]
                        }
                    ],
                    "output": "Cancelled by user",
                    "terminalName": "Zencoder-17d8e2da-5ee5-483a-96d1-15c236432536"
                }
            ],
            "context": {
                "author": "Coding Agent",
                "operationId": "c742037d-9d76-49cb-be84-66993ab1151c"
            },
            "createdAt": 1750331565179,
            "isInternal": false
        }
    ],
    "isAgent": true,
    "isNameGenerated": true,
    "isCustomAgent": false
}
}